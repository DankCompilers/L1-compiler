/\(/		{ return LPAREN }
/\)/		{ return RPAREN }
/;[a-zA-Z0-9_]*$/ {  /* ignore comments */ }
/[ \t]+/	{ /*ignore whitespace */ }

/:go/		{ return GOLABEL }
/return/	{ return RETURN }
/print/	{ return PRINT }
/allocate/	{ return ALLOCATE }
/array-error/	{ return ARRAYERROR }
/cjump/	{ return CJUMP }
/goto/	{ return GOTO }
/<-/	{ return ASSIGN }
/call/ { return CALL }
/tail-call/	{ return TAILCALL }

/\n/	{ /* ignore */}

/0|-?([1-9][0-9]*)/	{
                      lval.n,_ = strconv.Atoi(yylex.Text());
                      if lval.n >= 0 {
                        if lval.n <= 6 {
                          return NAT6
                        } else if lval.n <= 255 {
                          return NAT8
                        } else {
                          return NAT
                        }
                      } else {
                        return NEG
                      }
                    }
/rcx/	{ lval.s = yylex.Text(); return RCX }
/(rdi)|(rsi)|(rdx)|(r8)|(r9)/		{ lval.s = yylex.Text(); return A }
/(rax)|(rbx)|(rbp)|(r10)|(r11)|(r12)|(r13)|(r14)|(r15)/	{ lval.s = yylex.Text(); return W}
/rsp/		{ lval.s = yylex.Text(); return X }
/(<=?)|=/		{ lval.s = yylex.Text(); return CMP }
/(<<=)|(>>=)/	{ lval.s = yylex.Text(); return SOP }
/(\+=)|(-=)|(\*=)|(&=)/	{ lval.s = yylex.Text(); return AOP }
/^:[A-ZA-Z_][A-ZA-Z_0-9]*$/		{ lval.s = yylex.Text(); return LABEL }
/./	{ fmt.Printf("Found invalid input on line: %d\n", yylex.Line()) }

//


package L1
import ("fmt";"strconv")


func (yylex Lexer) Error(e string) {
  yylex.p.err = fmt.Sprintf(":%v:%v: error: %q undeclared", yylex.Line()+1, yylex.Column(), yylex.Text())
}
